## 图形学背题大纲

[TOC]

### 1.坐标系转换图

模型空间->世界空间->摄像机空间->裁剪空间->屏幕空间

![7](.\img\7.png)

### 2.三个重要的空间变化矩阵

MVP矩阵。（model transform、view transform、projection transform）



### 3.渲染管线流程

#### 广义上的图像渲染

1. **应用程序阶段**

   主要是CPU与内存打交道，例如碰撞检测，计算好的数据（顶点坐标、法向量、纹理坐标、纹理）就会通过数据总线传给图形硬件 。主要任务为在应用程序阶段的末端，将需要在屏幕上（具体形式取决于具体输入设备）显示出来绘制的几何体（也就是绘制图元，rendering primitives，如点、线、矩形等）输入到绘制管线的下一个阶段。

2. **几何阶段**

   几何阶段主要负责大部分多边形操作和顶点操作。可以将这个阶段进一步划分成如下几个功能阶段：

   - 模型视点变换 Model & View Transform
   - 顶点着色 Vertex Shading
   - 投影 Projection
   - 裁剪 Clipping
   - 屏幕映射 Screen Mapping

3. **光栅化阶段**

   给定经过变换和投影之后的顶点，颜色以及纹理坐标（均来自于几何阶段），给每个像素（Pixel）正确配色，以便正确绘制整幅图像。即从二维顶点所处的屏幕空间（所有顶点都包含Z值即深度值，及各种与相关的着色信息）到屏幕上的像素的转换。

   与几何阶段相似，该阶段细分为几个功能阶段：

   - 三角形设定（Triangle Setup）阶段

   - 三角形遍历（Triangle Traversal）阶段

   - 像素着色（Pixel Shading）阶段

     主要任务：计算所有需逐像素操作的过程。例如**贴图纹理采样**

   - 融合（Merging）阶段

     主要任务：合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色、可见性问题（alpha通道、模板缓冲器、帧缓冲器等）

#### GPU渲染管线：

1. **几何阶段：**

   - 顶点着色器

     顶点着色器可以对每个顶点进行诸如变换和变形在内的很多操作，提供了修改/创建/忽略顶点相关属性的功能，这些顶点属性包括颜色、法线、纹理坐标和位置。顶点着色器的必须完成的任务是将顶点从模型空间转换到齐次裁剪空间。

   - 几何着色器

     几何着色器是可选的，完全可编程的阶段，主要对图元（点、线、三角形）的顶点进行操作。几何着色器接收顶点着色器的输出作为输入，通过高效的几何运算，将数据输出，数据随后经过几何阶段和光栅化阶段的其他处理后，会发送给片段着色器。

   - 裁剪

   - 屏幕映射

2. **光栅化阶段：**

   - 三角形设定

   - 三角形遍历

   - 像素着色器

     常常又称为片断着色器，片元着色器(Fragment Shader，OpenGL中的叫法)，是完全可编程的阶段，主要作用是进行像素的处理，让复杂的着色方程在每一个像素上执行

     片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色

   - 合并阶段

     其除了进行合并操作，还分管颜色修改（Color Modifying），Z缓冲（Z-buffer），混合（Blend），模板（Stencil）和相关缓存的处理。

     各种测试的顺序：像素所有者测试（PixelOwnershipTest）、裁剪测试（ScissorTest）【前两者是OpenGL内部实现的】、模板测试（StencilTest）和深度测试（DepthTest）、混合（Blending）、抖动（Dithering）

     

### 4.各种着色器的作用

见上

### 5.光栅化图形学

1. DDA算法

   dx>dy时，直线Y=kx+b，当 △x=1时，△y=k。

   dx<dy时，直线x=y/k-b/k，当 △y=1时，△x=1/k。

2. Bresenham算法

   见OneNote



### 6.深度/模板测试

#### 深度测试

深度测试在片段着色器运行之后(并且模板测试运行之后)在屏幕空间中执行的。

一旦启用深度测试，如果片段通过深度测试，OpenGL自动在深度缓冲区存储片段的 z 值，如果深度测试失败，那么相应地丢弃该片段。在某些情况下我们需要进行深度测试并相应地丢弃片段，但我们不希望更新深度缓冲区，基本上，可以使用一个只读的深度缓冲区。

我们因此需要一些方法来转换这些视图空间 z 值到 [0，1] 的范围内，方法之一就是线性将它们转换为 [0，1] 范围内。下面的 (线性) 方程把 z 值转换为 0.0 和 1.0 之间的值 :
$$
F_{depth} = \frac{z-near}{far-near}
$$
然而，在实践中是几乎从来不使用这样的线性深度缓冲区。正确的投影特性的非线性深度方程是和1/z成正比的 。这样基本上做的是在z很近是的高精度和 z 很远的时候的低精度。用几秒钟想一想: 我们真的需要让1000单位远的物体和只有1单位远的物体的深度值有相同的精度吗?线性方程没有考虑这一点。

由于非线性函数是和 1/z 成正比，例如1.0 和 2.0 之间的 z 值，将变为 1.0 到 0.5之间， 这样在z非常小的时候给了我们很高的精度。50.0 和 100.0 之间的 Z 值将只占 2%的浮点数的精度，这正是我们想要的。这类方程，也需要近和远距离考虑，下面给出:
$$
F_{depth} = \frac{1/z-1/near}{1/far-1/near}
$$
![8](.\img\8.png)

两个平面或三角形如此紧密相互平行深度缓冲区不具有足够的精度以至于无法得到哪一个靠前。结果是，这两个形状不断似乎切换顺序导致怪异出问题。这被称为**深度冲突(Z-fighting)**

防止深度冲突的方法：1.让物体之间不要离得太近；2.尽可能把近平面设置得远一些



#### 模板测试

片段处理器->模板测试（模板缓冲）->深度测试（深度缓冲）

模板缓冲先清空模板缓冲设置所有片段的模板值为0，然后开启矩形片段用1填充。场景中的模板值为1的那些片段才会被渲染（其他的都被丢弃）。

![9](.\img\9.png)

无论我们在渲染哪里的片段，模板缓冲操作都允许我们把模板缓冲设置为一个特定值。改变模板缓冲的内容实际上就是对模板缓冲进行写入。在同一次（或接下来的）渲染迭代我们可以读取这些值来决定丢弃还是保留这些片段。当使用模板缓冲的时候，你可以随心所欲，但是需要遵守下面的原则：

- 开启模板缓冲写入。
- 渲染物体，更新模板缓冲。
- 关闭模板缓冲写入。
- 渲染（其他）物体，这次基于模板缓冲内容丢弃特定片段。

使用模板缓冲我们可以基于场景中已经绘制的片段，来决定是否丢弃特定的片段。



### 7.透明度测试

1. 对于全透明物体，我们可以简单的选择丢弃像素而不是混合
2. 渲染半透明物体时需要开启blending，但是为了避免渲染错误，需为物体进行排序，先绘制最远的物体，最后绘制最近的物体。普通的无混合的物体仍然可以使用深度缓冲正常绘制，所以不必排序，但是必须保证在透明物体绘制完成前绘制完毕。



### 8.GLSL着色器程序创建的细节，uniform in out

1. 着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。

2. GLSL定义了`in`和`out`关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。

3. 顶点着色器：为了定义顶点数据该如何管理，我们使用`location`这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。`layout (location = 0)`。顶点着色器需要为它的输入提供一个额外的`layout`标识，这样我们才能把它链接到顶点数据。

   ```glsl
   #version 330 core
   layout (location = 0) in vec3 position; // position变量的属性位置值为0
   
   out vec4 vertexColor; // 为片段着色器指定一个颜色输出
   
   void main()
   {
       gl_Position = vec4(position, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数
       vertexColor = vec4(0.5f, 0.0f, 0.0f, 1.0f); // 把输出变量设置为暗红色
   }
   ```

4. 片段着色器：需要一个`vec4`颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）

   ```glsl
   #version 330 core
   in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）
   
   out vec4 color; // 片段着色器输出的变量名可以任意命名，类型必须是vec4
   
   void main()
   {
       color = vertexColor;
   }
   ```

5. uniform:是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。

   - uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。
   - 无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。



### 9.透视投影 矩阵计算

![10](.\img\10.png)



### 10.phong式光照模型

冯氏光照模型的主要结构由3个元素组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。

![basic_lighting_phong](.\img\basic_lighting_phong.png)

1. 环境光照：即使在黑暗的情况下，世界上也仍然有一些光亮(月亮、一个来自远处的光)，所以物体永远不会是完全黑暗的。我们使用环境光照来模拟这种情况，也就是无论如何永远都给物体一些颜色。
2. 漫反射光照：拟一个发光物对物体的方向性影响(Directional Impact)。它是冯氏光照模型最显著的组成部分。面向光源的一面比其他面会更亮。
3. 镜面光照：模拟有光泽物体上面出现的亮点。镜面光照的颜色，相比于物体的颜色更倾向于光的颜色。







### 14.景深的原理

![11](.\img\11.png)









