## C++背题大纲

[TOC]

### 0.c++内存分配方式

在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
　　**栈**：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
　　**堆**：就是那些由 `new`分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
　　**自由存储区**：就是那些由`malloc`等分配的内存块，他和堆是十分相似的，不过它是用`free`来结束自己的生命的。
　　**全局/静态存储区**：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。程序结束后由系统统一释放。
　　**常量存储区**：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

### 1.虚函数

>定义一个函数为虚函数，不代表函数为不被实现的函数。
>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
>定义一个函数为纯虚函数，才代表函数没有被实现。
>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

1. **虚函数的作用**

   为了实现动态多态（运行时决定调用哪一个），与之相对的是静态多态（编译时决定，如函数重载、模板类的非虚函数调用）

2. **虚函数底层如何实现**

   通过维护虚函数表和VPTR指针来实现。即虚函数表+虚表指针

   编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，**每个类使用一个虚函数表，每个类对象用一个虚表指针**。

3. **VPTR什么时候被初始化？**

   在构造函数的时候执行初始化。对象在创建时，由编译器对VPTR指针进行初始化；只有当对象的构造完全结束后VPTR的指向才最终决定下来。

   父类对象的VPTR指向父类的虚函数表，子类对象的VPTR指向子类的虚函数表。

   定义子类对象时，VPTR先指向父类的虚函数表，在父类构造完成之后，子类的VPTR才指向自己的虚函数表。（**两阶段**）（这也就是在父类或者子类的构造函数中调用虚成员函数不会实现多态的原因，这是一道面试题）

4. **虚函数+MI，派生类的VPTR怎么被初始化？怎么存放？**

   ![img](https://uploader.shimo.im/f/08sspo2PMoAPHu99.png!original)

5. **虚函数表放在哪里**

   放在全局数据区。c++程序所占用的内存一般分为：栈区,堆区,程序代码区（存放函数体的二进制代码）,全局数据区(静态区),文字常量区.

   

6. **构造函数不能是虚函数，为什么？**

   虚函数的指针要靠构造函数初始化。

   从存储空间角度，虚函数对应一个指向vtable虚函数表的指针，这大家都知道，可是这个指向vtable的指针其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。（**构造的时候还无所谓虚表指针的概念，使用上无法引用**）

   构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。。。

7. **析构函数必须是虚函数，为什么？**

   举例 `base* p = new Derived()`，在析构的时候`delete p;`，如果析构函数不是虚函数，delete的时候结果是未定义的，通常来说是`Derived`的对象没有被销毁。相当于只销毁了`base`部分的内容，造成一个诡异的局部销毁的对象。

   但是无端将析构函数都设置为虚函数是不对的。如果class中没有其他virtual函数，这就说明当前这个class没意图被当作一个base class，这时候将其声明为virtual是不合适的，因为会增加这个类的存储开销。

   同时设计的类不能继承STL，因为STL中析构函数通常不是virtual的。*《Effective C++》条款07*

8. **析构函数可以抛出异常吗？为什么不可以？**

   如果析构函数需要调用delete，但是在执行delete之前就抛出异常中止了程序，会导致内存泄漏，进而引发更多异常。

   有几种做法：1.抛出异常就用`abort()`结束程序 ；2.吞下发生的异常，仅仅记录一下（通常不是个好办法）；  3. 重新设计接口，使得客户有机会对异常做出反应：将责任从析构函数上转移到用户手上（提供一个普通函数而非析构函数处理这个异常）*《Effective C++》条款08*

9. **可以在构造函数和析构函数中调用virtual函数吗？不可以**

   在构造和析构期间不要调用virtual函数，因为这类调用从来不会下降到`derive class`(比起当前执行构造函数和析构函数的那层来说)

   派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。同样，进入基类析构函数时，对象也是基类类型。这样并不会出现多态，所以没有必要调用虚函数*《Effective C++》条款09*

   

### 2.纯虚函数

含有纯虚函数的类不能实例化，就是一个抽象类

`virtual fun() = 0;`



### 3.内存泄漏 内存溢出 野指针

**内存泄漏**：new了没delete

**内存溢出**：程序在申请内存的时候没有足够的内存空间，原因可能有：

​	内存真的装满了；代码死循环；递归调用太深，堆栈溢出。

**野指针**：定义了个指针没有初始化，delete/free指针后没有置空，指向的对象生命周期已经过了

- 递归调用太深了会怎么样？怎么解决？

  会导致栈溢出：每调用一次方法，就会在栈上创建一个栈帧（方法结束后弹出栈帧）

  解决方法:

  ​	改成循环、用个变量记录递归次数、尾递归（调用多少次都只占一个栈帧）

- 内存泄漏怎么定位

  用什么方法检测？ 【CRT】

  怎么定位到具体哪一行代码发生了内存泄漏？【用CRT看看是第多少次操作泄漏的，然后再设个断点到那里停下。。（都是CRT的函数）】



### 4.访问控制

1. **class/struct里成员的默认访问控制**

   - 默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。

2. **成员的访问控制细节（private protected public 可不可以被 类的实例/类的友元访问）**

   类的实例：可以访问public

   类的友元：可以访问一切public protected private

   类的派生类：可以访问public protected

3. **class/struct继承链里的默认访问控制**

   - 默认的继承访问权。class默认的是private继承， struct默认的是public继承。
   - struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。子类是class默认就是private继承。

4. **继承链中的访问控制细节** https://www.cnblogs.com/qlwy/archive/2011/08/25/2153584.html

   - public继承，派生类的成员函数能看到什么，派生类的实例能看到什么

     基类的一切不变的加入到派生类

   - protected继承……

     private protected protected

   - private继承……

     private private private 	



### 5.类中对象分布

1. **一个空类sizeof**

   1。类的实例化就是给每一个实例在内存中分配一块地址。空类被实例化时，会由编译器隐含的添加一个字节。所以空类的size为1。

2. **一个类中有static对象的sizeof**

   1。静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员，但不影响类的大小。不管这个类产生了多少个实例，还是派生了多少新的类，静态数据成员只有一个实例。

3. **一个空类继承了一个基类的sizeof**

   基类大小

4. **多重继承时的内存分配（多重继承还带virtual继承时的分配）**

   ![image-20200717213237910](./img/1.png)

5. **决定一个类有多大的因素（6条）**

   类的大小与构造函数，析构函数，普通成员函数无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响

   虚函数对类的大小有影响，是因为虚函数表指针带来的影响

   虚继承对类的大小有影响，是因为虚基表指针带来的影响

   空类的大小是一个特殊情况,空类的大小为1



### 6.overload重载 override覆盖 overwrite重写的区别

1. **overload重载：**

   ```c++
   int func(int x)
   int func(int x, int y)
   ```

   如果写成：

   ```c++
   int func(int x)
   int func(int x, int y=0)  // 在调用func(1)的时候会报错，非唯一匹配
   ```

   如果写成

   ```c++
   double func()
   int func()
   ```

   会报错，返回值不能算在函数重载，重载只有参数

2. **override是覆盖**

   就是派生类里重写了基类virtual的部分（参数什么的都必须完全相同）。

   C++11里有关键字override（表示自己重写了）和final（声明基类函数不能再重写了）

   override的特例，如果有默认参数，就不会动态绑定了（默认参数的值会在编译时确定）

3. **overwrite是重写**

   就是派生类里重写了基类同名函数（除了override的部分）













